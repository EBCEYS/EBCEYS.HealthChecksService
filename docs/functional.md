# Описание функционала

## Запуск

При запуске сервиса хелсчеки настриваются следующим образом:

1. Через апи *docker-a* запрашиваются все контейнеры, поддерживающие проверку здоровья. Контейнер считается поддерживающим проверку, если у него есть лейбл взятый из *HEALTHCHECKS_LABEL_ENABLED_NAME*. Данные проверки имеют постфикс *-ebceys-healthz*.
1. Если включены пинги сервисов (*HEALTHCHECKS_USE_PING=true*), то они добавляются как дополнительные проверки. Данные проверки имеют постфикс *-ping*.
1. Если в кофигурационном файле сервисов (*HEALTHCHECKS_SERVICE_CONFIG_FILE*) есть настройки, то они также добавляются. Имя проверки берется из файла (тег *serviceName*).

## *HealthChecks*
### *EBCEYS HealthChecks*

Пути запросов берутся из [библиотеки](https://github.com/EBCEYS/EBCEYS.ContainersEnvironment?tab=readme-ov-file#healthchecks).

Опрашивается апи через *HealthzStatusRoute*.

Процес проверки следующий:

![ebceys.healthchecks](./ebceyshealthchecksactivity.png)

1. Проверка наличия лейбла из *HEALTHCHECKS_LABEL_IS_EBCEYS*. Если нет, то считаем, что контейнер здоров.
1. Берется лейбл *HEALTHCHECKS_LABEL_HOSTNAME*. Если нет, то берется имя контейнера.
1. Берется лейбл *HEALTHCHECKS_LABEL_PORT*. Если нет, то берется *8080*.
1. Отправляется запрос по пути *http://{hostname}:{port}/healthz/status*.
1. Если нет связи или ответ *unhealthy*, то считаем, что контейнер "нездоров".

### *Ping healtchecks*

Включаются при *HEALTHCHECKS_USE_PING=true*.

Использует утилиту *ping*.

Процесс проверки следующий:

1. Берется лейбл *HEALTHCHECKS_LABEL_HOSTNAME*. Если нет, то берется имя контейнера.
1. Отправляется пинг на контейнер.
1. Если пинг успешный, то контейнер считается "здоровым". Иначе нет.

### *Service healthchecks*

Для добавления проверок здоровья сервисов используется файл, указываемый в *HEALTHCHECKS_SERVICE_CONFIG_FILE*. Если ничего не указано, то функционал не включается.

Пример файла:
```json
{
	"healthChecks":
	{
		"RabbitMQ": 
		[
			{
				"serviceName":"rabbitmq",
				"container":"rabbitmq",
				"connectionString":"amqp://guest:guest@rabbitmq:5672/"
			}
		]
	}
}
```
* *healthchecks* - идет перечисление подключаемый сервисов. И является словарем, где ключ - тип сервиса, а значение - массив настроек проверок здоровья.
* *serviceName* - имя проверки здоровья.
* *container* - имя или *ID* контейнера.
* *connectionString* - строка подключения к сервису.

Поддерживаемые типы сервисов:
```cs
public enum SupportedHealthCheckServices
{
    None,
    RabbitMQ,
    PostgreSQL,
    Redis,
    MongoDB,
    ElasticSearch
}
```

*None* используется если не удалось распарсить ключ из словаря.

Список поддерживаемых сервисов будет пополняться.

Контейнеры подключатся, только если у них в лейблах указана необходимость проверок здоровья.

## *Containers cache*

Каждые 30 секунд сервис дергает апи докера для получения списка контейнеров и сохранения их в кеш.

К каждому хелсчеку добавляется тег с идентификатором контейнера. Это нужно, чтобы внутри хелсчека доставать из кеша информацию о контейнере.

## *HealthChecks processor*

Сервис периодически (период указывается в *HEALTHCHECKS_PROCESSOR_PERIOD*) дергает все хелсчеки.

Для каждого хелсчека выполняется следующий алгоритм:

![healthcheck.processor](./healthcheckprocessor.png)

1. Проверяется, что информация о контейнере есть в кеше. Если нет, то идем в следующий хелсчек.
1. Проверяется, что статус хелсчека *unhealthy*. Если нет, то идем в следующий хелсчек.
1. Если *HEALTHCHECKS_PROCESS_ONLY_IF_CONTAINER_RUNNING=true* и статус контейнера не *running*, то идем в слеудующий.
1. Если предыдущий статус контейнера отличный от *unhealthy*, то начинаем обработку контейнера.

## *Container processor*

Обработчик периодически считывает задачи обработки контейнера из очереди.

Для контейнера из очереди выполняется следующий алгоритм:

1. Если для контейнера указано действие по сохранению логов и *HEALTHCHECKS_SAVE_LOGS_ON_UNHEALTHY=true*, то создаем файл *{LOG_SAVER_BASE_PATH}/{containerName}/{currentDate(dd-MM-yyyy)}/{currentTime(HH-mm-ss)}_{containerName}.log*. Считываем текущий лог из контейнера и сохраняем в файл.
1. Если для контейнера указано действие по перезагрузке контейнера и у контейнера в лейбле указана перезагрузка при *unhealthy*, то пытаемся перезагрузить контейнер.